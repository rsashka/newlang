# Синтаксис

EN

- Основы
 - Именование объектов
 - Программыне модули
 - Пространства имен
 - Макросы
- Операторы и управляющие конструкции
  - Создания объектов и присвоения новых значений
  - Присваивание значения сразу нескольким переменным и оператор распаковки словаря
  - Арифметические операторы
  - Операторы сравнения
  - Проверка типа (имени класса объекта)
  - Утиная типизация
- Управляющие конструкции
  - Условный оператор
  - Оценка выражения
  - Операторы циклов
  - Операторы прерывания выполнения (оператор возврата)
- Системные имена
- DSL
- Сравнение синтаксиса с другими языками (Python, С++, С#)

## Основы
- Операторы разделяются точкой с запятой «;».
- Отступы и переводы строк игнорируются.
- Однострочные комментарии начинаются с символа «#» до перевода строки, что соответствует комментариям в стиле Python и Bash.
- Многострочные комментарии соответствуют стилю С/С++ и должны располагаться между символами /\* и \*/. Многосточные комментарии могут быть вложенными.
- Последовательность команд, которая должна выполняться как единое целое заключается в фигурные скобки «{}» и возвращает результат последней операции *(что очень похоже на оператор **запятая** в языках С/С++)*.

### Правила именования объектов и типов данных

В качестве идентификаторов объектов и типов данных можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, при условии, что первый символ идентификатора не является цифрой. Подчерк в начале имени или двойные подчерки в начале и в конце имени имеют специальное значение.

Перед именем может быть указан специальный префикс (модификатор), который состоит из одного символа и имеет определнное значение:
#### Префиксы (модификаторы)
- **$** — в начале имени обозначает локальную переменную, время жизни которой ограничено текущей областью видимости и при её завершении локальная переменная уничтожается.
- **:** — двоеточие вначале идентификатора используется для указания имени [типа](https://newlang.net/types.html)
- **::** — двойные двоеточия являются разделителями для указания пространства имен
- **@** — Префикс **@** обозначает программный модуль или объект в указанном программном модуле
- **\\** — обратная коса черта является модификатором для имени макроса

Если перед именем модификатор не указан, то сперва ищется макрос, потом на локальная переменная и в последнюю очередь модуль (объекта модуля).

### Локальные и глобальные переменные
В *NewLang* по умолчанию переменная создается как глобальная статическая, которая сохраняет свое состояние между вызовами.

Чтобы создать локальную перемененную, перед её именем необходимо указать знак доллара **$**, тогда такая переменная будет уничтожаться при выходе из текущей области видимости. 
Если условно классифицировать эти два варианта переменных, то можно считать, что переменная по умолчанию создается в куче, а локальная с префиксом **$** на стеке.

Семантика локальных переменных, а так же аргументов у функций очень похожа на аргументы в bash скриптах, где **$1** или **$arg** — порядковый номер или имя аргумента.

### Пространства имен
*NewLang* одновременно поддерживает и пространства имен, как в языке C++, так и модульную структуру кода как в языках Java и Python.
Синтаксис для указания пространства имен очень похож на С++. Имена разделяются двойным двоеточием, а для определение пространства имен, его нужно указать перед открывающейся фигурной скобкой.
```
ns:: { # Пространство имен ns

    var := 0; # Имя переменной будет ns::var

    name:: {
        var := 0; # Имя переменной будет ns::name::var
        ::var := 1; # Переменная из глобального пространства имен
    }

    :: { # Глобальное пространство имен
        var := 1; 
    }
}
```


obj {
    .field = 1; 
    .prop();
};

#Python
# 1) without using with statement
file = open('file_path', 'w')
file.write('hello world !')
file.close()


 
# 2) without using with statement
file = open('file_path', 'w')
try:
    file.write('hello world')
finally:
    file.close()

open('file_path', 'w') {
    .write('hello world !');
    .close();
}

  
Python3

# using with statement
with open('file_path', 'w') as file:
    file.write('hello world !')


# a simple file writer object
 
class MessageWriter(object):
    def __init__(self, file_name):
        self.file_name = file_name
     
    def __enter__(self):
        self.file = open(self.file_name, 'w')
        return self.file
 
    def __exit__(self, *args):
        self.file.close()
 
# using with statement with MessageWriter
 
with MessageWriter('my_file.txt') as xfile:
    xfile.write('hello world')





# a simple file writer object
:MessageWriter {
    def __init__(self, file_name):
        self.file_name = file_name
     
    def __enter__(self):
        self.file = open(self.file_name, 'w')
        return self.file
 
    def __exit__(self, *args):
        self.file.close()
}

# using with statement with MessageWriter
 
MessageWriter('my_file.txt') {
    .write('hello world');
};







from contextlib import contextmanager
 
 
class MessageWriter(object):
    def __init__(self, filename):
        self.file_name = filename
 
    @contextmanager
    def open_file(self):
        try:
            file = open(self.file_name, 'w')
            yield file
        finally:
            file.close()
 
 
# usage
message_writer = MessageWriter('hello.txt')
with message_writer.open_file() as my_file:
    my_file.write('hello world')




:MessageWriter(object) {
    def __init__(self, filename):
        self.file_name = filename
 
    @contextmanager
    def open_file(self):
        try:
            file = open(self.file_name, 'w')
            yield file
        finally:
            file.close()
 
}

# usage
message_writer = MessageWriter('hello.txt')
with message_writer.open_file() as my_file:
    my_file.write('hello world')

### Программные модули
В *NewLang* реализована концепция программных модулей - которая повторяет идею иерархического расположения файлов в структуре каталогов файловой системы, так же, как это сделано в языках Python и Java. Имя программного модуля начинается на префикс **@**, а структура каталогов указывается через точку. 

Причем в именовании объектов концепции программных модулей и пространства имен объединены. Например, полное имя переменой можно записать с указанием программного модуля `@root.dir.module::ns::name::var`, где **root** и **dir** это каталоги в файловой системе, а **module** — имя файла, т.е. *root/dir/module.nlp*

Области видимости объектов определяются аналогично прияным в языке Python с помощью подчерков перед именем переменной.

Один подчерк соответствует защищенной, а два подчерка - приватной области видимости объекта в соответствующем модуле или классе.
Но так же как и в языке Python области видимости больше соответствуют "джентльменской" договоренности и при явном указании имени, доступ к защищенным объектам можно получить указав их полное имя. Системные поля и объекты начинаются и заканчиваются на два подчерка.



## Макросы

Макросы в **NewLang**, это один или несколько последовательных терминов, которые заменяются на другой термин 
или на целую синтаксическую конструкцию (последовательность лексем). 

Макросы обработываются во время работы **лексера**, т.е. перед передачей последовательности лексем в парсер, 
что позволяет с их помощью изменять любые последовательности термины и даже сам синтаксис языка, например, 
для реализации собственных диалектов DSL.

### Определение макросов

Для определения макросов используется такой-же синтаксис, как и для других объектов языка.
Определение макроса состоит из трех частей **<имя макроса> <оператор создания/присвоения> <тело макроса>** и завершающая точка с запятой **;**,
т.е. применяются операторы **::=**/**::-**, **=** или **:=**/**:-** для создания нового объекта, 
присвоение нового значения уже существующему объекту или для создания/присвоения нового значения объекту 
не зависимо от его наличия или отсутствия.


### Тело макроса

Телом макроса могут быть корректное выражение языка, последовательность лексем (которые заключается в двойные обратные слеши, 
т.е. `\\лексема1 лексема1\\`) или обычная текстовая строка (обрамленная в тройные обратные слеши, т.е. `\\\ текстовая строка \\\`).

### Имя макроса

Именем макроса может быть одна или нескольких лексем (терминов), которые заключаются между двумя обратными слешами.
В имени макроса кроме лексем (терминов) могут присутствовать один или несколько шаблонов.

*Шаблон* — это термин, который при сопоставлении последовательности лексем с идентификатором макроса 
может заменяться любым другим одиночным термином (реализуется сопоставление имени макроса по образцу (шаблону).

Для создания термина-шаблона в начале его идентификатора нужно поставить знак доллара (что соответствует записи имени локальной переменой), 
т. е. `\\одна_лексема\\, \\целых три термина\\ или \\термин $шаблон1 $шаблон2\\`.

Имена макросов считаются одинаковыми, если количество элементов в их именах совпадает, термины и шаблоны располагаются 
на тех же самых местах, а сами термины в идентификаторах одинаковые.

### Удаление макросов

Для удаления макросов используется специальный синтаксис: `\\\\ name \\\\;` или `\\\\ два термина \\\\;`, 
т.е. необходимо указать идентификатор макроса между четырмя обратными слешами.

```bash
    # Тело макроса из текстовой строки (как в препроцессоре С/С++)
    \\macro_str\\  := \\\ строка - тело макроса \\\; # Строка для лексера

    # Оператор удаления макроса
    \\\\ macro_str \\\\;
```

### Аргументы макросов

Во всех языках программирования макросы можно определять как с аргументами, так и без аргументов. 
И как правило, макропроцессор считает макросы с аргументами и без оных идентичными, что не позволяет определять 
два макроса с одинаковыми именами, один из которых будет с аргументами (скобками), а другой без них.  

Но такое ограничение усложняет заменую одного термина на другой, если термины могут применяться в двух разных варинатах использования,
т.е. и с аргументами и без аргументов одновремнно. (Например, в С/С++ это вызов функции и получение адреса функции).

Из-за этого в язык **NewLang** добавлен еще один вариант макроса (алиас), который игнорирует наличие аргументов 
и может использоваться как со скобкам (аргументами), так и без них, а имена макросов сравниваются без учета аргументов (скобок).


```bash
    \\alias\\ :- term; # Алиас - определение без аргументов
    
    # Использование макроса - алиаса
    alias; # ОК -> term;
    alias(args); # ОК -> term(args);

    # Но 
    \\var\\ := term; 
    \\call()\\ := term(); 

    # Использование
    var; # ОК -> term;
    call(); # ОК -> term();

    var(); # Ошибка (var определен без аргументов) 
    call; # Ошибка (call определен с аргументами) 
```

Для создания макросов без аргументов (алиасов) используются операторы как для создания чистых функций (**::-** или **:-**). 

При сопоставлении идентификаторов таких макросов учитываются только последовательность лексем и шаблонов, 
что позволяет из примернять как к функциям, так и к обычным переменным для замены одних терминов на другие, 
а любые виды скобок (и данные внутри них) при сопоставлении игнорируются.  

#### Раскрытие аргументов в теле макроса

У обычных макросов термины и шаблоны в имени макроса могут иметь аргументы, которые указываются в разных видах скобках. 
Обычные макросы при сопоставлении с последовательностью лексем требуют наличие аргументов в определении имени маркоса.  

Чтобы в теле макроса указать место для вставки аргумента, его нужно записать как имя локальной переменой, 
но перед ним добавить обратный слеш, т.е. **\\$name**.

Произвольное количество аргументов у макроса отмечается троеточием "...", а место для вставки этих аргументов отмечается 
специальной лексемой. Для вставки всех аргументов из конкретного идентификатора используется лексема 
с указанием соотвутствующего имени, например, **\\$name(\*)**, **\\$name<\*>** или **\\$name[\*]** в зависимости от типов скобок, 
где **name**, это имя термина или шаблона, который имеет аргументы (т.е. после которого стоят скобки соответствующего вида).  

Для вставки количества реально переданных аргументов используется лексемы **\\$name(#)**, **\\$name<#>** 
или **\\$name[#]** с указанием соответствующего идентификатора.


#### Дополнительные возможности макросов

По аналогии с препроцессором С/С++ для соединения двух лексем в одну в теле макроса используется оператор **\\##**, 
а для преобразование лексемы текстову строку оператор **\\#**, например, `\\macro($arg)\\ := \\ func_ \## \$arg(\#arg) \\;`, 
тогда вызов `macro(name);` будет преобразован в `func_name ("name");`

*Парсер при обработке макросов может анализировать информацию о типах данных, если она указана.* 
*Но на текущий момент типы данных в макросах никак не обрабатываются и это одна из обязательных фич, которая будет реализована в будущем.*

### Примеры макросов

```bash
    # Обычные макросы (тело макроса корректное выражение)
    \\macro\\        := replace();
    \\macro2(arg)\\  := { call(\$arg); call()};
    \\name1 name2\\  := replace();

    # Тело макросов из последовательности лексем
    \\if(...)\\    := \\ [ \$if(*) ]--> \\; # Выражение может быть не полным
    \\elif(...)\\  := \\ ,[ \$elif(*) ]--> \\;
    \\else\\       := \\ ,[_]--> \\;
 
    # Классическая запись условного оператора
    # с использованием определнных выше макросов
    if( condition ){
        ...
    } elif( condition2 ) {
        ...
    } else {
        ...
    };
```




# Систематизация реализации макросов

Разбор макросов происходит в лексере. Определением макроса всегда является целая строка, 
которая заканчивается точкой с запятой, а идентификатором макроса всегда выступает последовательность лексем:
```bash
    \\ id \\ := macro;
    \\ id \\ := \\ \\;
    \\ id \\ := \\\ \\\;
```
Хранилищем текущих максросов является объект класса MacroBuffer. 
Последовательность лексем идентификатора (id) макроса должна сохраняется в отдельном поле термина и однозначно его идентифицирует.
Первый термин в идентификаторе хранится как ключ hashmap, а дальше происходит поиск полным перебором.
Этапы работы с макросами

- Входные термины из лексера получаются вызовом GetNextToken, внутри которой и происходит раскрытие макросов.
Внутренний буфер заполняется до окончания строки (выражения), т.е. до символа ';' или <END>, после чего производится 
поиск макросов в объекте MacroBuffer для текущей последовательности лексем в буфере.

- Если макрос найден, то соответствющая ему последоваетльность заменяется на тело макроса и происходит переход 
на повторный анализ входного буфера.

- Если макрос не найден, то данные передаются в парсер для дальнейшего синтаксическго анализа.

- Для этого во входном потоке лексем (parser.y) во время оператората создания/присвоения вызывается функция проверки на макрос.
MacroBuffer::CheckMacroAndConvertDel($$), и после этого выходному значению присваивается результат выполнения driver.MacroEval($$),
и в дальнейшем этот макрос никак не обработывается.

- Создание макросов, проверка на дубликаты и логические ошибки в определении происходит путем обращения к методам объекта MacroBuffer.


# Ограничения текущей реализации !!!!

На текущий момент макросы делаются для следующих сценариев использования:

- DSL для keyword based syntax (if, else, return, match, while  и т.д.) - (1 термин с произвольными аргументами и без) - требуется сейчас !!!


- Определения (func, class) - (несколько терминов с аргументами и без аргументов) - Реализация ООП и импорт С++ классов
- Модификации при определениях (override) - (несколько терминов и шаблоны с аргументами и без аргументов) - Реализация ООП и импорт С++ классов


# МАКРОСЫ БЕЗ АРГУМЕНТОВ ИЛИ ВСЕ АРГУМЕНТЫ СРАЗУ !!!!!
# анализа аргументов или их типов не производится !!!







    /*
     * Макросы хрянтся как фрагменты AST в виде объектов типа Term,
     * так как создаются после обработки парсером по правилам стандратной грамматики.
     * 
     * Но анализ входных данных на предмет раскрытия макросов проиходит из потока (последовательности) лексем,
     * т.е. **ДО** обработки парсером, так как при раскрытии макросов может меняться грамматика выражений.
     * 
     * Функция \ref CompareMacro сравнивает входной буфер (последовательность лексем)
     * на предмет возможного соответствия одному конкретному макросу.
     * Сравниваются только ключевые словам без учета аргументов в скобках, 
     * но само наличие аргументов проверяется ??????????????????
     * 
     * Проблема:
     * К функции можно обратится с целью её вызова (указав после имени скобки), 
     * так и по имени без скобок (например для получения ссылки на объект).
     * Так и к переменной можно обратиться только по имени, 
     * так и указав скобки после имени как к функции (при копировании объекта).
     * 
     * Сделать один макрос под оба сценария (со скобками и без скобок) не получится, так как непонятно, 
     * что делать с аргументами при раскрытии тела макроса, когда они не указаны.
     * 
     * Но может быть следует переименовывать только одно имя без учета скобок,
     * например, оставив такую возможность только для одиночных макросов.
     * 
     * \name -> name или name (...), hash: name
     * но \name(...) -> name(...), а name - ошибка !!!!  hash: name
     * 
     * Или все же следует различать макросы со скобками и без скобок как два разных объекта???
     * \name := name2;  и \name(...) := name2(...); будут разными объектами
     * 
     * Или добавить макросы-алиасы без аргументов только для переименования отдельных терминов?
     * \alias :- name2; но как их отличать от обычных макросов в операции удаления?
     * Или вообще не нужно отличать и оставить только один варинат (либо макрос, либо алиас)
     * Тода вопрос со скобками закрывается сам собой, алиасы всегда без скобок,
     * макросы со скбками или без скобок, но должно быть полное соответствие.
     * 
     * \\ name name2 \\ -> name name2, но name name2(...) - ошибка!!! (hash: name,name2)
     * \\ name name2(...) \\ -> name name2(...), но name name2 - ошибка !!!! (hash: name,name2)
     * \\ name name2[...](...) \\ -> name name2[...](...), но name name2 - ошибка !!!!  ( hash: name,name2 )
     * \\ name $tmpl[...](...) name3\\ -> name $tmpl[...](...) name3, но name $tmpl name3 - ошибка !!!!  ( hash: name,$,name3 )
     * 
     * Но!
     * \\ name name2 \\ ::-  -> name name2 - ок, но name name2(...) - ок
     * \\ name $tmpl name3\\ ::- -> name $tmpl[...](...) name3 - ок, name $tmpl(...) name3[...] - ок
     * 
     * 
     * 
     * Для последовательности лексем требуется полное соответствие с учетом скобок ???
     * и может ли быть несколько скобок одного типа (несколько крыглях, или несколько квардратных????
     * <Может быть несколько скобок одного типа, например, при указании типа у аргументов или типа возвращаемого значения.>
     * 
     * \\ name name2 \\ -> name name2, но name name2(...) - ошибка!!! (hash: name,name2)
     * \\ name name2(...) \\ -> name name2(...), но name name2 - ошибка !!!! (hash: name,name2)
     * \\ name name2[...](...) \\ -> name name2[...](...), но name name2 - ошибка !!!!  ( hash: name,name2 )
     * \\ name $tmpl[...](...) name3\\ -> name $tmpl[...](...) name3, но name $tmpl name3 - ошибка !!!!  ( hash: name,$,name3 )
     * 
     * Проблема скобок возникает из-за сценария замены одного термина на другой, 
     * который есть в препроцессоре С/С++, но отсутствует при реализации с использованием шаблонов.
     * 
     *      
     */






Макросы используются и для превращеня исходного кода *NewLang* в более привычный синтаксис на основе [ключевых слов](https://newlang.net/syntax_dsl.html), так как такой тест гораздо легче воспринимается при последующем чтении исходного кода.


[Например:](https://newlang.net/syntax_dsl.html).
```
    \\if(...)\\    ::= \\ [ \$* ]--> \\;
    \\while(...)\\ ::= \\ [\$*] <-> \\;
    \\return $arg\\::=  \\ -- \$arg -- \\;
    \\true\\ ::= 1;
```

Тогда цикл до 5:
```
count:=1;
[ 1 ] <-> {
    [count>5] --> {
        -- 42 --;
    };
    count+=1;
};
```

будет выглядеть более привычно
```
count:=1;
while( true ) {
    if(count>5) {
        return 42;
    };
    count+=1;
};
```






## Операторы и управляющие конструкции

### Создания объектов и присвоения новых значений

Для создания объектов и присвоения им новых значений в NewLang используется сразу три разных оператора:
- **::=** - используется только для создания новых объектов, а если объект с таким именем уже существует, то генерируется ошибка.
- **:=** - используется для тех же целей, но если объект с таким именем уже существует, то ошибки не происходит, а новое значение присваивается уже существующему объекту.
- **=** - применяется только для присвоения значения уже существующим объектам, а если объект с указанным именем отсутствует, то происходит ошибка выполнения.

Использование трех разных операторов для создания/изменения объектов позволяет более гибко контролировать подобные операции и выявлять логические ошибки в коде на более раннем этапе. 

Например, при определении класса `:NewClass2`:
```bash
    :NewClass := :Class() { # Базовый класс
        filed ::= 2;
        method() ::= {};
    };
    :NewClass2 := :NewClass() {
        filed ::= 2; # Будет ошибка, т.к. field уже есть в базовом классе
        method() = {}; # Аналог override, т.к. method должен существовать в базовом классе
    };
```

Если же контролировать момент создание объектов и присвоения им значений не требуется, то можно пользоваться единственным оператором **:=**.

```bash
    var := 1.0; # Создать новую переменную var без явного указания типа
    var := 100; # Присвоить новое значение уже существующей переменной
    printf := :Pointer('printf(format:FmtChar, ...):Int32'); /* Создать новый или переопределить существующий объект printf */
```

### Присваивание значения сразу нескольким переменным и оператор распаковки словаря
*NewLang* поддерживает операцию присваивания сразу нескольким переменным, которые должны быть перечислены через запятую слева от оператора присвоения. С правой стороны от оператора присвоения может находится одно или несколько значений или оператор распаковки словаря **...** (многоточие). Оператор распаковки словаря можно использовать и при передаче аргументов в функцию. 

Причем словарь может быть указан и с левой стороны от оператора присвоения и таким образом можно записать самый простой способ перебора всех его элементов: `item, dict := ... dict;`, т.е. когда в цикле первый элемент словаря сохраняется в переменную item, а из самого словаря удаляется.

Пример реализации цикла foreach для суммирования всех элементов словаря (или одномерного тензора) с использованием оператора раскрытия списка:
```
    summa := 0;
    dict := (1,2,3,4,5,);
    \while( dict ) {
        # Первый элемент словаря перемещается в item
        item, dict := ... dict; 
        summa += item;
    };
```

### Арифметические операторы

Все операторы имеют парный аналог с присвоением значения:
- **+** и **+=** — сложение арифметических типов данных;
- **-** и **-=** — вычитание арифметических типов данных;
- **/** и **/=** — деление (результат число с плавающей точкой);
- **//** и **//**= — целочисленное деление с округлением к меньшему числу (как в Python);
- **\*** и **\*=** — умножение;
- **\*\*** и **\*\*=** — возведение в степень (он же используется и для повторения текстовых строк);

### Операторы сравнения:
- **<**, **>**, **<=**, **>=** — классические для сравнения скаляров
- **==** и **!=** — операторы сравнения с автоматическим приведением совместимых типов для любых объектов
- **===** и **!==** — операторы точного сравнения для любых объектов (автоматического приведения типов не выполняется)

### Проверка типа (имени класса объекта):
Для оператора проверки имени типа (класса) объекта используется символ тильда **~**. Он немного похож на оператор *instanceof* в Java. Левым операндом должен быть проверяемый объект, а правым — проверяемый тип, который можно указать строкой литералом, переменной строкового типа или именем проверяемого класса непосредственно. Результатом операции будет истина, если правый операнд содержит название класса проверяемого объекта или он присутствует в иерархии наследования.

```
    name := "class"; # Строковая переменная с именем класса
    var ~ name; 
    var ~ :class; # Сравнение с типом
    var ~ "class"; # Имя типа как строка литерал
```

### Утиная типизация
Оператор утиной типизации, два символа тильды **~~** — приблизительный аналог функции *isinstance()* в Python, который для простых типов сравнивает непосредственную совместимость типа левого операнда по отношению к правому. А для словарей и классов в левом операнде проверяется наличие всех имен полей, присутствующих у правого операнда, т.е.:

```
    (field1=«value», field2=2,) ~~ (); # Истина (т. е. левый операнд словарь)
    (field1=«value», field2=2,) ~~ (field1=_); # Тоже истина (т. к. поле field1 присутствует у левого операнда)
    (field1=«value», field2=2,) ~~ (not_found=_); # Ложь, т.к. поле not_found у левого операнда отсутствует
```

Строгая утиная типизация **~~~** — для простых типов сравнивается идентичности типов без учета совместимости, а для составных типов происходит сравнение всех свойств с помощью оператора строгого равенства. Для данной операции, пустой тип совместим только с другим пустим типом.

## Управляющие конструкции

К управляющим конструкциям языка NewLang относятся условный оператор, два вида циклов, оператор оценки выражения, оператор прерывания последовательности выполнения команд и перехват прерывания. Операторы проверки условий всегда указываются в квадратных скобках, а последовательность команд для выполнения — в фигурных.

### Условный оператор

В качестве оператора проверки условия используется синтаксическая конструкция, соответствующая по смыслу термину «следует», т.е. два тире и угловая скобка **-->**. Такая запись условного оператора очень похожа на математическую и легко объединяется в последовательности для проверки множественных условий вида «else if».

В общем случае условный оператор имеет вид: **[** условие **] --> {** действие **};** или с условием иначе **[** условие **] --> {** действие **}, [_] --> {** действие иначе **};**

Для наглядности записанный с отступами:
```bash
    [ условие1 ] --> { действие1 },
    [ условие2 ] --> действие2,
    [ условие3 ] --> действие3,
    [_] --> {действие_иначе};
```

Или тоже самое, но с использованием [макросов из модуля dsl](https://newlang.net/syntax_dsl.html).:
```bash
    if( условие1 ) { 
        действие1 
    } elif( условие2 ) действие2
    elif( условие3 ) действие3
    else { 
        действие_иначе
    };
```

### Оценка выражения

Синтаксическая конструкция с помощью которой реализуется аналог оператора switch выглядит следующим образом:
```bash
    [ $var ] ==> {
        [1] --> { code }, # Выполнится проверка условия $var == 1
        [1, 2] --> { code }, # Выполнится проверка условия ($var == 1 || $var == 2)
        [_] --> { code default }; # Ветка условия иначе
    };
```
Или тоже самое, но с использованием [макросов из модуля dsl](https://newlang.net/syntax_dsl.html).:
```bash
    match( $var ) ==> {
        case( 1 ) { code },
        case( 1, 2 ) { code },
        else { code default };
    };
```

Этот оператор очень похож на *Pattern Matching*, но все же не является сопоставлением с образцом, 
а скорее более краткая запись множественного оператора сравнения, 
так как в качестве оператора для оценки могут быть использован любые имеющиеся операторы сравнения на равенство:
- **==>** — проверка на равенство с приведением типов;
- **===>** — проверка на точное равенство;
- **~>** — проверка типа (имени класса);
- **~~>** — утиная типизация;
- **~~~>** — строгая утиная типизация.

Но если в качестве оператора сравнения использовать оператор утиной типизации, то оценка выражения превращается в классический *Pattern Matching*:
```bash
    $value := (f1=1, f2="2",);
    match( $value ) ~~~> {
        case((f1=_, ), (f1=_, f2=0, )) { ... code ... }, # Поле f2 отсутствует или число 
        case((f1=_, f2="",), (f1=_, f2='',)) { ... code ... }, # Поле f2 строка
        else { ... code default ... }; # Код по умолчанию
    };
```

### Операторы циклов

Для записи циклов используются оператор **<->**, который ставится между условием цикла (проверкой логического выражения) и телом цикла. Условие цикла записывается в квадратных скобках и в зависимости от взаимного расположения цикл может быть с предусловием (while) или постусловием (dowhile):
```bash
    [условие while] <-> {
        тело цикла while
    };

    {
        тело цикла dowhile
    } <-> [условие dowhile];
```

Пример реализации цикла foreach для суммирования всех элементов словаря (или одномерного тензора) с использованием оператора раскрытия списка:
```
    summa := 0;
    dict := (1,2,3,4,5,);
    [ dict ] <-> { # Условие цикла, пока есть данные
        item, dict := ... dict; # Результат оператора распаковка словаря - первый его элемент перемещается в item
        summa += item; # Вычисление суммы всех элементов словаря
    };
```

Цикл с предусловием (**while**) поддерживает конструкцию **else**, которая выполняется, если условие входа в цикл не было выполнено. 

> *Внимание! 
Это поведение отличается от аналогичных конструкций в языке Python, у которого секция **else** выполняется всегда, кроме прерывания цикла по break.*

Ветка **else** у оператора цикла записывается так же как и ветка *иначе* в условном операторе, т.е. 
```
    [ cond ] <-> {
        ...
    },[_] --> {
        ...
    };
```
Или тоже самое, но с использованием [макросов из модуля dsl](https://newlang.net/syntax_dsl.html).:
```
    while(cond) {
        ...
    } else {
        ... # Выполнится, только если cond будет false при входе в цикл
    };
```


## Операторы прерывания выполнения (оператор возврата)

### Прерывания, возврат и обработка ошибок
Изменена, а точнее полностью переделана идеология возвратов из функций и обработки ошибок. Теперь она чем-то похожа на подход, примененный в Ruby. Любая последовательность команд заключенные в фигурные скобки (в том числе тело функции), рассматривается как блок кода у которого нет специального оператора аналога **return**, который возвращает какое либо значение. Просто любой блок кода всегда возвращает последнее вычисленное значение (это чем то похоже на оператор «запятая» в языках C/C++).

Для того, чтобы прервать выполнение кода используются две разные команды - прерывания, которые условно можно назвать *положительным* и *отрицательным* результатом. Что примерно соответствует семантике их записи. "Отрицательное" прерывание записывается в виде двух минусов, а "положительное" прерывание в виде двух плюсов, т.е. **-\-** или **++**.

По умолчанию данные операции возвращают пустое значение. Чтобы прерывание вернуло результат, возвращаемые данные нужно записывать между парой соответствующих символов, т.е. **-\-** 100 **-\-**, что является близким аналогом оператора `return 100;` в других языках программирования, а **++**«Строка»**++** - аналогом `return «Строка»;`.

Хотя более точным аналогом этих операторов будет все таки не **return**, а **throw**, т.к. эти команды не только прерывают выполнение последовательности команд в блоке, но их еще можно «ловить». Для этого используется блок кода с соответствующей семантикой, **{+** … **+}** - блок кода, который перехватывает положительные прерывания и **{-** … **-}** - блок кода, который перехватывает прерывания, созданные операторами **--**. 

Подобная концепция (в явном виде не разделять возвраты из функций и обработку исключений), хоть и выглядит немного необычной, но позволяет реализовывать несколько очень полезных финтов, которые сложно реализуемые в обычных языках программирования.

Например, возврат из нескольких вложенных функций без необходимости обрабатывать результат возврата каждой из них. В этом примере функция *Test* перехватывает "положительные" прерывания из вложенных функций:
```bash
    Test0(arg) := { if($arg==0) return("DONE - 0"); «FAIL» };
    Test1(arg) := { if($arg==1) return("DONE - 1"); Test0($arg); };
    Test(arg) := {+ if($arg >= 0) Test1($arg); $arg; +};

    Test(0); # Вернет «DONE — 0» возврат из вложенной функции Test0
    Test(1); # Вернет «DONE — 1» возврат из вложенной функции Test1
    Test(2); # Вернет «FAIL» возврат из вложенной функции Test0
    Test(-2); # Вернет -2 — возврат из функции Test
```
Есть еще блок `{* … *}`, который перехватывает оба типа прерываний. Такой блок кода поддерживает типизацию возвращаемого значения, что позволяет в явном виде указывать типы данных, которые нужно перехватывать. Например, `{* ... *} :Type1` — будет перехвачено прерывание вида `++ :Type1 ++` или `--:Type1--`, что позволяет очень гибко формировать логику работы программы.

Блоки кода с перехватом исключений также поддерживают оператор иначе (*\else*) который, по аналогии с оператором *\else* в циклах, выполняется только тогда, если прерывания не произошло.

Можно указать сразу несколько типов, которые нужно перехватывать:
```bash
    {* 
        ....
    *} <:Type1, :Type2, :Type3>;
```








### Специальные идентификаторы
- **$0** — текущий объект для класса или None в остальных случаях.
- **$\*** — Все аргументы текущей функции или модуля
- **@\*** — Все аргументы запущенной программы

- **$$** — родительский объект (в том числе и при переопределении функций).
- **@@** — Системный контекст
- **@$** — Текущий модуль

Проверить, является ли текущий модуль основным, можно протестировав его нулевой аргумент. У основного модуля программы, нулевой аргумент всегда будет содержать имя исполняемого файла, а остальные аргументы соответствовать параметрам командной строки (если они есть). Если файл загружен как модуль,
то нулевой аргумент у модуля будет пустым.
```
# Аналог проверки в Python
# if __name__ == "__main__": 

[@$.$0] --> { # или \ifmain при использовании макросов из модуля @dsl
    ...
};
```

### Зарезервированные имена компилятора

При работе парсера *NewLang* автоматически генерируются несколько зарезервированных имен, которые можно использовать как обычные константы.
Большинство из них соответствуют макросам препроцессора у С/С++:

- \_\_FILE\_\_ - расширяется до полного пути к текущему файлу
- \_\_LINE\_\_ - содержит номер текущей строки
- \_\_TIMESTAMP\_\_ - дату и время последней модификации текущего файла
- \_\_MD5\_\_ - md5 хеш текущего файла

- \_\_DATE\_\_ - дата и время начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)
- \_\_COUNTER\_\_ - целочисленный счетчик, который увеличивает свое значение при каждом обращении
- \_\_NLC_VER\_\_ - версия NewLang

- \_\_SOURCE_GIT\_\_ - идентификатор исходных файлов NewLang git репозитория, использованных при сборке
- \_\_DATE_BUILD\_\_ - дата сборки исходников NewLang
- \_\_SOURCE_BUILD\_\_ - дата сборки и git идентификатор исходных файлов NewLang одной строкой

### Системные свойства

Несмотря на то, что не все объекты *NewLang* являются классами с точки зрения [реализованной концепции ООП](https://newlang.net/type_oop.html), тем не менее, каждый объект имеет системные свойства, которые можно считать во время выполнения как обычные свойства объекта:

#### У всех переменных (объектов) есть системные свойства
- \_\_name\_\_ - краткое имя переменной (объекта)
- \_\_full_name\_\_ - полное имя переменной, включая имя модуля и пространство имен
- \_\_type\_\_ - текущий тип переменной. Может изменится при некоторых операциях
- \_\_type_fixed\_\_ - тип переменной (объекта) который не может измениться (ограничитель)
- \_\_module\_\_ - имя модуля в котором определена переменная (объект)
- \_\_class\_\_ - имя класса переменной или пусто, если объект не является классом
- \_\_base\_\_ - словарь со списком базовых классов или пусто, если объект не является классом
- \_\_size\_\_ - количество элементов у объекта, если применимо или :None 

- \_\_doc\_\_ - документация по текущему объекту (если есть, иначе пустая строка)
- \_\_str\_\_ - строковое представление объекта для дампа
- \_\_source\_\_ - исходный текст модуля или функции

#### Системные свойства у модулей
- \_\_file\_\_ - полный путь к файлу модуля (соответствует макросу \_\_FILE\_\_)
- \_\_timestamp\_\_ - дата и время последней модификации файла модуля (соответствует макросу \_\_TIMESTAMP\_\_)
- \_\_md5\_\_ - хеш исходных данных модуля (соответствует макросу \_\_MD5\_\_)




## Макросы

### Особенности ассоциативной памяти
Синтаксис языка *NewLang* основан на строгих правилах без использования ключевых слов, 
и как бы он не выглядел логичным, ассоциация по ключевым словам вспоминается гораздо легче, например **if**,
чем комбинация *минус минус правая угловая скобка* **-->**. 
Из-за этого имеет смысл использовать не "чистый" базовый синтаксис, а более привычный диалект с использованием ключевых слов. 

### Синтаксис на ключевых словах
В файле dsl.nlp находится набор макросов, которые расширяют базовый синтаксис *NewLang*, основанный на правилах,
набором предопределенных ключевых слов как в классических языках программирования. 
А при необходимости, их можно адаптировать или дополнить под собственную предметную область.


## Константы
### Логические
- **true**
- **yes**
- **false**
- **no**

### Системные имена
- **this** - Текущий объект (**$0**)
- **parent** - Родительский объект (**$$**)
- **args** - Все аргументы функции (**$\***)

- **sys** - Системный контекст запущенной программы (**@@**)
- **current** - Текущий модуль (**@$**)
- **cmd** - Все аргументы выполняющегося приложения из командной строки (**@\***)

### Типовые функции и проверки 
- **run('filename')** - Выполнить указанный файл (**@@('filename')**)
- **ifmain** - Проверка, если текущий модуль основной (**[@$.$0] -->** { ... })
- **ifload** - Проверка, если текущий модуль загружается впервые (**[@$.__load__] -->** { ... })

### Операторы
- **match(cond)** - Оператор [оценки выражения](https://newlang.net/ops.html#оценка-выражения)
- **if(...)** - Первый условный оператор (**[\$*]-->** { ... })
- **elif(...)** - Второй и все последующие (**,[\$*]-->** { ... })
- **else** - Оператор *иначе* (**,[_]-->** { ... })

- **\while(cond)** - Оператор цикла с предусловием (**[\\$cond] <->** { ... } )
- **\dowhile(cond)** - Оператор цикла с постусловием ({ ... } **<->[\\$cond]**)

- **\iter(obj, ... )** - Создание итератора ( **\\$obj** ? (\$*) )
- **\next(obj, ... )** - Следующий элемент итератора ( **\\$obj** ! (\$*) )
- **\curr(obj, ... )** - Текущий элемент итератора ( **\\$obj** !? (\$*) )
- **\first(obj)** - Перейти на первый элемент итератора ( **\\$obj** !! )
- **\all(obj)** - Получить сразу все элементы итератора ( **\\$obj** ??)


### Прерывания
- **return** - Положительное прерывание (**++**)
- **return(...)**- Положительное прерывание с возвратом значения (**++** \\$value **++**) 

- **error** - Отрицательное прерывание (**-\-**)
- **error(...)** - Отрицательное прерывание с возвратом значения (**-\-** \\$value **-\-**)

- **break+** и **break-** - Выход из цикла:
```
    while(...) {+
        ++ :Break ++   
    +}
    while(...) {-
        -- :Break --
    -}
```
- **continue+** и **continue-** - В начало цикла:
```
    while(...) {+
        ++ :Continue ++   
    +}
    while(...) {-
        -- :Continue --
    -}
```


